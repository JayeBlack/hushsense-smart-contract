const { Client, ContractCreateFlow, PrivateKey, AccountId, Hbar, ContractId, ContractCallQuery } = require("@hashgraph/sdk");
const fs = require("fs");
require("dotenv").config();

async function main() {
  console.log("ðŸš€ Deploying HushSense contract using Hedera SDK...");

  // Configure client for Hedera mainnet
  const operatorId = AccountId.fromString(process.env.MY_ACCOUNT_ID);
  const operatorKey = PrivateKey.fromString(process.env.MY_PRIVATE_KEY_DER); // Use DER format for SDK
  const client = Client.forMainnet();
  client.setOperator(operatorId, operatorKey);
  client.setDefaultMaxTransactionFee(new Hbar(10)); // 10 HBAR
  client.setMaxQueryPayment(new Hbar(0.1)); // 0.1 HBAR for queries

  // Load compiled contract bytecode and ABI (generated by Hardhat)
  const contractName = "HushSense";
  const contractArtifact = require("../artifacts/contracts/HushSense.sol/HushSense.json");
  const bytecode = contractArtifact.bytecode;
  const abi = contractArtifact.abi;

  console.log(`ðŸ“‹ Deploying ${contractName} with operator: ${operatorId.toString()}`);
  console.log(`ðŸ”‘ Using private key: ${operatorKey.publicKey.toString()}`);

  // Create contract deployment transaction
  const contractCreateTx = new ContractCreateFlow()
    .setBytecode(bytecode)
    .setGas(6_000_000)
    .setAdminKey(operatorKey.publicKey);

  // Sign and execute
  const txResponse = await contractCreateTx.execute(client);
  const receipt = await txResponse.getReceipt(client);
  const contractId = receipt.contractId;

  console.log(`ðŸŽ‰ Contract deployed successfully!`);
  console.log(`ðŸ“‹ Contract ID: ${contractId.toString()}`);
  console.log(`ðŸ”— Transaction ID: ${txResponse.transactionId.toString()}`);

  // Wait for record and handle EVM address retrieval
  let record;
  let evmAddress;
  for (let attempt = 0; attempt < 5; attempt++) {
    try {
      record = await txResponse.getRecord(client);
      if (record.contractCreateResult) {
        evmAddress = `0x${record.contractCreateResult.toString(16).padStart(40, '0')}`;
        console.log(`ðŸ“‹ EVM Address: ${evmAddress}`);
        break;
      }
      console.log(`âš ï¸ EVM address not yet available, retrying (${attempt + 1}/5)...`);
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
    } catch (error) {
      console.warn(`âš ï¸ Error fetching record, retrying (${attempt + 1}/5):`, error.message);
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  if (!evmAddress) {
    console.warn("âš ï¸ Could not retrieve EVM address after retries. Using contract ID for now.");
    evmAddress = `0x${contractId.num.toString(16).padStart(40, '0')}`; // Fallback approximation
    console.log(`ðŸ“‹ Approximate EVM Address: ${evmAddress}`);
  }

  // Update .env file with contract ID
  updateEnvFile(contractId.toString());

  // Verify deployment
  console.log("\nðŸ” Verifying deployment...");
  const clientForQuery = Client.forMainnet().setOperator(operatorId, operatorKey);
  const contract = new ContractId(contractId.toString());
  const query = new ContractCallQuery()
    .setContractId(contract)
    .setGas(100_000)
    .setFunction("name");
  const name = await query.execute(clientForQuery);
  console.log(`âœ… Token Name: ${name.toString()}`);

  const totalSupplyQuery = new ContractCallQuery()
    .setContractId(contract)
    .setGas(100_000)
    .setFunction("totalSupply");
  const totalSupply = await totalSupplyQuery.execute(clientForQuery);
  console.log(`âœ… Total Supply: ${totalSupply.toString()} wei (10000000000000000000000000000 expected)`);

  return {
    contractId: contractId.toString(),
    evmAddress,
    transactionId: txResponse.transactionId.toString(),
  };
}

function updateEnvFile(contractId) {
  try {
    const envPath = ".env";
    let envContent = fs.readFileSync(envPath, "utf8");

    const contractLine = `HUSHSENSE_CONTRACT_ADDRESS=${contractId}`;

    if (envContent.includes("HUSHSENSE_CONTRACT_ADDRESS=")) {
      envContent = envContent.replace(
        /HUSHSENSE_CONTRACT_ADDRESS=.*/,
        contractLine
      );
    } else {
      envContent += `\n${contractLine}\n`;
    }

    fs.writeFileSync(envPath, envContent);
    console.log("ðŸ“ Updated .env file with contract ID");
  } catch (error) {
    console.warn("âš ï¸ Could not update .env file:", error.message);
  }
}

main()
  .then((result) => {
    console.log("\nðŸŽŠ Deployment completed successfully!");
    console.log("ðŸ“‹ Final Result:");
    Object.entries(result).forEach(([key, value]) => {
      console.log(`   ${key}: ${value}`);
    });

    console.log("\nðŸŽ¯ Next steps:");
    console.log("1. Your HushSense token contract is now live on Hedera mainnet");
    console.log("2. You can mint rewards using the mintReward function");
    console.log("3. Users can burn tokens using the burn function");
    console.log("4. The contract ID has been saved to your .env file");

    process.exit(0);
  })
  .catch((error) => {
    console.error("ðŸ’¥ Deployment failed");
    console.error("Error:", error.message);
    process.exit(1);
  });